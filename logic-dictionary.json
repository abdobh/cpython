{
    "rules": {
        "self_built_algorithm_simple_http_request": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple HTTP request.\n# Discovered concept: A concept for which a working code example was not found online.\nimport requests\ndef fetch_url(url):\n    try:\n        response = requests.get(url, timeout=5)\n        print(f\"Successfully fetched {url}. Status Code: {response.status_code}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Failed to fetch {url}. Error: {e}\")\nfetch_url(\"https://example.com\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:39:27.728790"
        },
        "self_built_algorithm_simple_stack_operation": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple stack.\n# Discovered concept: المفهوم: `A queue that optimizes storage by consolidating consecutive identical elements into item-count pairs.`\nmy_stack = []\nprint(\"Adding items to the stack...\")\nfor i in range(('https://example.com',)):\n    my_stack.append(i)\nprint(f\"Stack after adding items: {my_stack}\")\nprint(\"Removing items from the stack...\")\nwhile my_stack:\n    item = my_stack.pop()\n    print(f\"Popped item: {item}\")\nprint(f\"Stack after removing all items: {my_stack}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:39:58.045538"
        },
        "self_built_algorithm_polymorphism_example": {
            "type": "polymorphism",
            "value": "\n# A self-generated algorithm for polymorphism.\n# Discovered concept: A concept for which a working code example was not found online.\nclass Animal:\n    def speak(self):\n        return \"I am an animal.\"\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\nfor animal in [Dog(), Cat()]:\n    print(animal.speak())\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:40:45.139650"
        },
        "self_built_algorithm_fibonacci_with_memoization": {
            "type": "fibonacci",
            "value": "\n# A self-generated algorithm for dynamic programming with memoization.\n# Discovered concept: المفهوم:\n`A practical guide demonstrating essential Python data structures, algorithms, and problem-solving patterns.`\ndef fibonacci_with_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_with_memo(n-1, memo) + fibonacci_with_memo(n-2, memo)\n    return memo[n]\nnumber = 14\nresult = fibonacci_with_memo(number)\nprint(f\"The {number}th Fibonacci number using dynamic programming is: {result}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:41:14.524861"
        },
        "self_built_algorithm_dijkstra_pathfinding": {
            "type": "dijkstra",
            "value": "\n# A self-generated algorithm for Dijkstra's shortest path.\n# Discovered concept: A concept for which a working code example was not found online.\nimport heapq\ndef dijkstra(graph, start, end):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    path = {}\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        if current_node == end:\n            break\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                path[neighbor] = current_node\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances, path\ngraph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'C': 2, 'D': 5}, 'C': {'A': 4, 'B': 2, 'D': 1}, 'D': {'B': 5, 'C': 1, 'E': 3}, 'E': {}}\nstart_node = 'A'\nend_node = 'E'\ndistances, path = dijkstra(graph, start_node, end_node)\nprint(f\"Shortest distances from {start_node}: {distances}\")\nprint(f\"Shortest path to {end_node}: {path}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:41:40.847897"
        },
        "self_built_algorithm_create_simple_hashmap": {
            "type": "create",
            "value": "\n# A self-generated algorithm for a hash map (dictionary).\n# Discovered concept: A concept for which a working code example was not found online.\nmy_dict = {}\nmy_dict[\"fruit_1\"] = \"apple\"\nmy_dict[\"fruit_2\"] = \"banana\"\nprint(f\"My dictionary: {my_dict}\")\nprint(f\"Value for 'fruit_1': {my_dict.get('fruit_1')}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:42:33.790208"
        },
        "self_built_algorithm_check_data_type": {
            "type": "check",
            "value": "\n# A self-generated algorithm to check data type.\n# Discovered concept: خادم ويب يعالج ويستجيب للأحداث في الوقت الفعلي من خدمة خارجية عبر الـ Webhooks.\ndata_item = [1, 2]\ndata_type = type(data_item).__name__\nprint(f\"نوع البيانات لـ {repr(data_item)} هو: {data_type}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:43:14.849514"
        },
        "self_built_algorithm_simple_bubble_sort": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple bubble sort.\n# Discovered concept: المفهوم: `Generating an ordered linear profile from spatially distributed data points.`\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\nmy_list = [1, 32, 20, 5, 1]\nsorted_list = bubble_sort(my_list)\nprint(f\"القائمة الأصلية: {my_list}\")\nprint(f\"القائمة بعد الفرز: {sorted_list}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:43:53.247982"
        },
        "self_built_algorithm_a_star_pathfinding": {
            "type": "a",
            "value": "\n# A self-generated algorithm for A* pathfinding on a grid.\n# Discovered concept: المفهوم: `Simulating and controlling a virtual physical environment where objects interact according to defined rules.`\nimport heapq\ndef a_star(grid, start, end):\n    rows, cols = len(grid), len(grid[0])\n    \n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    \n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {cell: float('inf') for row in grid for cell in [(i, j) for j in range(cols)] for i in range(rows)}\n    g_score[start] = 0\n    f_score = {cell: float('inf') for row in grid for cell in [(i, j) for j in range(cols)] for i in range(rows)}\n    f_score[start] = heuristic(start, end)\n    \n    while open_set:\n        current_f, current_cell = heapq.heappop(open_set)\n        \n        if current_cell == end:\n            path = []\n            while current_cell in came_from:\n                path.append(current_cell)\n                current_cell = came_from[current_cell]\n            path.append(start)\n            path.reverse()\n            return path\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_cell[0] + dx, current_cell[1] + dy)\n            if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0:\n                tentative_g_score = g_score[current_cell] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current_cell\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n                    \n    return None\ngrid = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nstart = (0, 0)\nend = (2, 3)\npath = a_star(grid, start, end)\nif path:\n    print(f\"Path found: {path}\")\nelse:\n    print(\"No path found.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:44:21.099617"
        }
    },
    "meta_rules": {
        "general": {
            "type": "general",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "networking": {
            "type": "networking",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "stacks_and_queues": {
            "type": "stacks_and_queues",
            "blueprint": "المفهوم: `A queue that optimizes storage by consolidating consecutive identical elements into item-count pairs.`"
        },
        "polymorphism": {
            "type": "polymorphism",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "dynamic_programming": {
            "type": "dynamic_programming",
            "blueprint": "المفهوم:\n`A practical guide demonstrating essential Python data structures, algorithms, and problem-solving patterns.`"
        },
        "dijkstra_pathfinding": {
            "type": "dijkstra_pathfinding",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "hash_maps": {
            "type": "hash_maps",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "data_types": {
            "type": "data_types",
            "blueprint": "خادم ويب يعالج ويستجيب للأحداث في الوقت الفعلي من خدمة خارجية عبر الـ Webhooks."
        },
        "sorting_algorithm": {
            "type": "sorting_algorithm",
            "blueprint": "المفهوم: `Generating an ordered linear profile from spatially distributed data points.`"
        },
        "a_star_pathfinding": {
            "type": "a_star_pathfinding",
            "blueprint": "المفهوم: `Simulating and controlling a virtual physical environment where objects interact according to defined rules.`"
        },
        "testing": {
            "type": "testing",
            "blueprint": "A concept for which a working code example was not found online."
        }
    }
}