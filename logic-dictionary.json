{
    "rules": {
        "self_built_algorithm_simple_http_request": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple HTTP request.\n# Discovered concept: A concept for which a working code example was not found online.\nimport requests\ndef fetch_url(url):\n    try:\n        response = requests.get(url, timeout=5)\n        print(f\"Successfully fetched {url}. Status Code: {response.status_code}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Failed to fetch {url}. Error: {e}\")\nfetch_url(\"https://example.com\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:39:27.728790"
        },
        "self_built_algorithm_simple_stack_operation": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple stack.\n# Discovered concept: المفهوم: `A queue that optimizes storage by consolidating consecutive identical elements into item-count pairs.`\nmy_stack = []\nprint(\"Adding items to the stack...\")\nfor i in range(('https://example.com',)):\n    my_stack.append(i)\nprint(f\"Stack after adding items: {my_stack}\")\nprint(\"Removing items from the stack...\")\nwhile my_stack:\n    item = my_stack.pop()\n    print(f\"Popped item: {item}\")\nprint(f\"Stack after removing all items: {my_stack}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:39:58.045538"
        },
        "self_built_algorithm_polymorphism_example": {
            "type": "polymorphism",
            "value": "\n# A self-generated algorithm for polymorphism.\n# Discovered concept: A concept for which a working code example was not found online.\nclass Animal:\n    def speak(self):\n        return \"I am an animal.\"\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\nfor animal in [Dog(), Cat()]:\n    print(animal.speak())\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:40:45.139650"
        },
        "self_built_algorithm_fibonacci_with_memoization": {
            "type": "fibonacci",
            "value": "\n# A self-generated algorithm for dynamic programming with memoization.\n# Discovered concept: المفهوم:\n`A practical guide demonstrating essential Python data structures, algorithms, and problem-solving patterns.`\ndef fibonacci_with_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_with_memo(n-1, memo) + fibonacci_with_memo(n-2, memo)\n    return memo[n]\nnumber = 14\nresult = fibonacci_with_memo(number)\nprint(f\"The {number}th Fibonacci number using dynamic programming is: {result}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:41:14.524861"
        },
        "self_built_algorithm_dijkstra_pathfinding": {
            "type": "dijkstra",
            "value": "\n# A self-generated algorithm for Dijkstra's shortest path.\n# Discovered concept: A concept for which a working code example was not found online.\nimport heapq\ndef dijkstra(graph, start, end):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    path = {}\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        if current_node == end:\n            break\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                path[neighbor] = current_node\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances, path\ngraph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'C': 2, 'D': 5}, 'C': {'A': 4, 'B': 2, 'D': 1}, 'D': {'B': 5, 'C': 1, 'E': 3}, 'E': {}}\nstart_node = 'A'\nend_node = 'E'\ndistances, path = dijkstra(graph, start_node, end_node)\nprint(f\"Shortest distances from {start_node}: {distances}\")\nprint(f\"Shortest path to {end_node}: {path}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:41:40.847897"
        },
        "self_built_algorithm_create_simple_hashmap": {
            "type": "create",
            "value": "\n# A self-generated algorithm for a hash map (dictionary).\n# Discovered concept: A concept for which a working code example was not found online.\nmy_dict = {}\nmy_dict[\"fruit_1\"] = \"apple\"\nmy_dict[\"fruit_2\"] = \"banana\"\nprint(f\"My dictionary: {my_dict}\")\nprint(f\"Value for 'fruit_1': {my_dict.get('fruit_1')}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:42:33.790208"
        },
        "self_built_algorithm_check_data_type": {
            "type": "check",
            "value": "\n# A self-generated algorithm to check data type.\n# Discovered concept: خادم ويب يعالج ويستجيب للأحداث في الوقت الفعلي من خدمة خارجية عبر الـ Webhooks.\ndata_item = [1, 2]\ndata_type = type(data_item).__name__\nprint(f\"نوع البيانات لـ {repr(data_item)} هو: {data_type}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:43:14.849514"
        },
        "self_built_algorithm_simple_bubble_sort": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple bubble sort.\n# Discovered concept: المفهوم: `Generating an ordered linear profile from spatially distributed data points.`\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\nmy_list = [1, 32, 20, 5, 1]\nsorted_list = bubble_sort(my_list)\nprint(f\"القائمة الأصلية: {my_list}\")\nprint(f\"القائمة بعد الفرز: {sorted_list}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:43:53.247982"
        },
        "self_built_algorithm_a_star_pathfinding": {
            "type": "a",
            "value": "\n# A self-generated algorithm for A* pathfinding on a grid.\n# Discovered concept: المفهوم: `Simulating and controlling a virtual physical environment where objects interact according to defined rules.`\nimport heapq\ndef a_star(grid, start, end):\n    rows, cols = len(grid), len(grid[0])\n    \n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    \n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {cell: float('inf') for row in grid for cell in [(i, j) for j in range(cols)] for i in range(rows)}\n    g_score[start] = 0\n    f_score = {cell: float('inf') for row in grid for cell in [(i, j) for j in range(cols)] for i in range(rows)}\n    f_score[start] = heuristic(start, end)\n    \n    while open_set:\n        current_f, current_cell = heapq.heappop(open_set)\n        \n        if current_cell == end:\n            path = []\n            while current_cell in came_from:\n                path.append(current_cell)\n                current_cell = came_from[current_cell]\n            path.append(start)\n            path.reverse()\n            return path\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_cell[0] + dx, current_cell[1] + dy)\n            if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0:\n                tentative_g_score = g_score[current_cell] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current_cell\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n                    \n    return None\ngrid = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nstart = (0, 0)\nend = (2, 3)\npath = a_star(grid, start, end)\nif path:\n    print(f\"Path found: {path}\")\nelse:\n    print(\"No path found.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:44:21.099617"
        },
        "self_built_algorithm_test_function_example": {
            "type": "test",
            "value": "\n# A self-generated algorithm for a simple test case.\n# Discovered concept: A concept for which a working code example was not found online.\ndef add(a, b):\n    return a + b\ndef run_test(func, *args, expected_result):\n    actual_result = func(*args)\n    if actual_result == expected_result:\n        print(f\"Test for {func.__name__} passed! Expected: {expected_result}, Got: {actual_result}\")\n    else:\n        print(f\"Test for {func.__name__} FAILED! Expected: {expected_result}, Got: {actual_result}\")\nrun_test(add, 2, 3, expected_result=5)\nrun_test(add, 1, 1, expected_result=3)\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:45:18.035253"
        },
        "self_built_algorithm_factorial_recursion": {
            "type": "factorial",
            "value": "\n# A self-generated algorithm using recursion.\n# Discovered concept: A function that calls itself to solve smaller versions of the same problem.\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\nnumber = 3\nresult = factorial(number)\nprint(f\"مضروب الرقم {number} هو: {result}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:45:56.841324"
        },
        "self_built_algorithm_git_commit": {
            "type": "git",
            "value": "\n# A self-generated algorithm for version control.\n# Discovered concept: المفهوم: `Software version and release information management.`\ndef git_commit_simulation(message):\n    print(f'\\n>>>>> simulating git commit -m \"{message}\"')\n    print(\"...processing changes...\")\n    print(\"...packaging files...\")\n    print(\"...creating new snapshot...\")\n    print(f\"Commit with message '{message}' successfully created.\")\n    \ngit_commit_simulation(\"first_commit\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:48:49.900688"
        },
        "self_built_algorithm_run_threaded_task": {
            "type": "run",
            "value": "\n# A self-generated algorithm for concurrency.\n# Discovered concept: A concept for which a working code example was not found online.\nimport threading\ndef task(name):\n    print(f\"Task {name} started.\")\n    time.sleep(random.uniform(0.5, 1.5))\n    print(f\"Task {name} finished.\")\nprint(\"Starting concurrent tasks...\")\nt1 = threading.Thread(target=task, args=(\"task1\",))\nt2 = threading.Thread(target=task, args=(\"task2\",))\nt1.start()\nt2.start()\nt1.join()\nt2.join()\nprint(\"All tasks are done.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:49:33.598498"
        },
        "self_built_algorithm_simple_addition_function": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple function.\n# Discovered concept: الكود:\n```py\nimport tensorflow as tf\nimport numpy as np\n\n\ndef create_samples(n_clusters, n_samples_per_cluster, n_features, embiggen_factor, seed):\n    np.random.seed(seed)\n    slices = []\n    centroids = []\n    # 为每个簇创建样本\n    for i in range(n_clusters):\n        samples = tf.random_normal((n_samples_per_cluster, n_features),\n                                   mean=0.0, stddev=5.0, dtype=tf.float32, seed=seed, name=\"cluster_{}\".format(i))\n        current_centroid = (np.random.random((1, n_features)) * embiggen_factor) - (embiggen_factor/2)\n        centroids.append(current_centroid)\n        samples += current_centroid\n        slices.append(samples)\n    # 创建一个大的“样本”数据集\n    samples = tf.concat(slices, 0, name='samples')\n    centroids = tf.concat(centroids, 0, name='centroids')\n    return centroids, samples\n```\nالمفهوم: `A function that generates synthetic data points organized into distinct clusters around randomly determined centers.`\ndef add_two_numbers(a, b):\n    return a + b\nresult = add_two_numbers(5, 4)\nprint(f\"ناتج جمع 5 و 4 هو: {result}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T06:50:20.206715"
        }
    },
    "meta_rules": {
        "general": {
            "type": "general",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "networking": {
            "type": "networking",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "stacks_and_queues": {
            "type": "stacks_and_queues",
            "blueprint": "المفهوم: `A queue that optimizes storage by consolidating consecutive identical elements into item-count pairs.`"
        },
        "polymorphism": {
            "type": "polymorphism",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "dynamic_programming": {
            "type": "dynamic_programming",
            "blueprint": "المفهوم:\n`A practical guide demonstrating essential Python data structures, algorithms, and problem-solving patterns.`"
        },
        "dijkstra_pathfinding": {
            "type": "dijkstra_pathfinding",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "hash_maps": {
            "type": "hash_maps",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "data_types": {
            "type": "data_types",
            "blueprint": "خادم ويب يعالج ويستجيب للأحداث في الوقت الفعلي من خدمة خارجية عبر الـ Webhooks."
        },
        "sorting_algorithm": {
            "type": "sorting_algorithm",
            "blueprint": "المفهوم: `Generating an ordered linear profile from spatially distributed data points.`"
        },
        "a_star_pathfinding": {
            "type": "a_star_pathfinding",
            "blueprint": "المفهوم: `Simulating and controlling a virtual physical environment where objects interact according to defined rules.`"
        },
        "testing": {
            "type": "testing",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "recursion": {
            "type": "recursion",
            "blueprint": "A function that calls itself to solve smaller versions of the same problem."
        },
        "classes": {
            "type": "classes",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "data_structures": {
            "type": "data_structures",
            "blueprint": "- المفهوم: `Assembling and operating a complex system using a high-level library API.`"
        },
        "version_control": {
            "type": "version_control",
            "blueprint": "المفهوم: `Software version and release information management.`"
        },
        "concurrency": {
            "type": "concurrency",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "functions": {
            "type": "functions",
            "blueprint": "الكود:\n```py\nimport tensorflow as tf\nimport numpy as np\n\n\ndef create_samples(n_clusters, n_samples_per_cluster, n_features, embiggen_factor, seed):\n    np.random.seed(seed)\n    slices = []\n    centroids = []\n    # 为每个簇创建样本\n    for i in range(n_clusters):\n        samples = tf.random_normal((n_samples_per_cluster, n_features),\n                                   mean=0.0, stddev=5.0, dtype=tf.float32, seed=seed, name=\"cluster_{}\".format(i))\n        current_centroid = (np.random.random((1, n_features)) * embiggen_factor) - (embiggen_factor/2)\n        centroids.append(current_centroid)\n        samples += current_centroid\n        slices.append(samples)\n    # 创建一个大的“样本”数据集\n    samples = tf.concat(slices, 0, name='samples')\n    centroids = tf.concat(centroids, 0, name='centroids')\n    return centroids, samples\n```\nالمفهوم: `A function that generates synthetic data points organized into distinct clusters around randomly determined centers.`"
        },
        "variables": {
            "type": "variables",
            "blueprint": "- الكود: `x = 35\n    y = x + 5\n    print(y)`\n- المفهوم: `Direct execution of statements to store and transform data into an observable output.`"
        }
    }
}