{
    "rules": {
        "self_built_algorithm_simple_http_request": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple HTTP request.\n# Discovered concept: A concept for which a working code example was not found online.\nimport requests\ndef fetch_url(url):\n    try:\n        response = requests.get(url, timeout=5)\n        print(f\"Successfully fetched {url}. Status Code: {response.status_code}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Failed to fetch {url}. Error: {e}\")\nfetch_url(\"https://example.com\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:00:28.293757"
        },
        "self_built_algorithm_simple_stack_operation": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple stack.\n# Discovered concept: المفهوم: `A queue that optimizes storage by consolidating consecutive identical elements into item-count pairs.`\nmy_stack = []\nprint(\"Adding items to the stack...\")\nfor i in range(1):\n    my_stack.append(i)\nprint(f\"Stack after adding items: {my_stack}\")\nprint(\"Removing items from the stack...\")\nwhile my_stack:\n    item = my_stack.pop()\n    print(f\"Popped item: {item}\")\nprint(f\"Stack after removing all items: {my_stack}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:53:44.052930"
        },
        "self_built_algorithm_polymorphism_example": {
            "type": "polymorphism",
            "value": "\n# A self-generated algorithm for polymorphism.\n# Discovered concept: A concept for which a working code example was not found online.\nclass Animal:\n    def speak(self):\n        return \"I am an animal.\"\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\nfor animal in [Dog(), Cat()]:\n    print(animal.speak())\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:45:59.251492"
        },
        "self_built_algorithm_fibonacci_with_memoization": {
            "type": "fibonacci",
            "value": "\n# A self-generated algorithm for dynamic programming with memoization.\n# Discovered concept: المفهوم:\n`A practical guide demonstrating essential Python data structures, algorithms, and problem-solving patterns.`\ndef fibonacci_with_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_with_memo(n-1, memo) + fibonacci_with_memo(n-2, memo)\n    return memo[n]\nnumber = 6\nresult = fibonacci_with_memo(number)\nprint(f\"The {number}th Fibonacci number using dynamic programming is: {result}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:02:59.488874"
        },
        "self_built_algorithm_dijkstra_pathfinding": {
            "type": "dijkstra",
            "value": "\n# A self-generated algorithm for Dijkstra's shortest path.\n# Discovered concept: A concept for which a working code example was not found online.\nimport heapq\ndef dijkstra(graph, start, end):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    path = {}\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        if current_node == end:\n            break\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                path[neighbor] = current_node\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances, path\ngraph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'C': 2, 'D': 5}, 'C': {'A': 4, 'B': 2, 'D': 1}, 'D': {'B': 5, 'C': 1, 'E': 3}, 'E': {}}\nstart_node = 'A'\nend_node = 'E'\ndistances, path = dijkstra(graph, start_node, end_node)\nprint(f\"Shortest distances from {start_node}: {distances}\")\nprint(f\"Shortest path to {end_node}: {path}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:01:45.323219"
        },
        "self_built_algorithm_create_simple_hashmap": {
            "type": "create",
            "value": "\n# A self-generated algorithm for a hash map (dictionary).\n# Discovered concept: A concept for which a working code example was not found online.\nmy_dict = {}\nmy_dict[\"fruit_1\"] = \"apple\"\nmy_dict[\"fruit_2\"] = \"banana\"\nprint(f\"My dictionary: {my_dict}\")\nprint(f\"Value for 'fruit_1': {my_dict.get('fruit_1')}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:03:25.161608"
        },
        "self_built_algorithm_check_data_type": {
            "type": "check",
            "value": "\n# A self-generated algorithm to check data type.\n# Discovered concept: خادم ويب يعالج ويستجيب للأحداث في الوقت الفعلي من خدمة خارجية عبر الـ Webhooks.\ndata_item = 10\ndata_type = type(data_item).__name__\nprint(f\"نوع البيانات لـ {repr(data_item)} هو: {data_type}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:58:35.136731"
        },
        "self_built_algorithm_simple_bubble_sort": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple bubble sort.\n# Discovered concept: المفهوم: `Generating an ordered linear profile from spatially distributed data points.`\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\nmy_list = [39, 13, 20, 44, 29]\nsorted_list = bubble_sort(my_list)\nprint(f\"القائمة الأصلية: {my_list}\")\nprint(f\"القائمة بعد الفرز: {sorted_list}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:02:36.009392"
        },
        "self_built_algorithm_a_star_pathfinding": {
            "type": "a",
            "value": "\n# A self-generated algorithm for A* pathfinding on a grid.\n# Discovered concept: المفهوم: `Simulating and controlling a virtual physical environment where objects interact according to defined rules.`\nimport heapq\ndef a_star(grid, start, end):\n    rows, cols = len(grid), len(grid[0])\n    \n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    \n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {cell: float('inf') for row in grid for cell in [(i, j) for j in range(cols)] for i in range(rows)}\n    g_score[start] = 0\n    f_score = {cell: float('inf') for row in grid for cell in [(i, j) for j in range(cols)] for i in range(rows)}\n    f_score[start] = heuristic(start, end)\n    \n    while open_set:\n        current_f, current_cell = heapq.heappop(open_set)\n        \n        if current_cell == end:\n            path = []\n            while current_cell in came_from:\n                path.append(current_cell)\n                current_cell = came_from[current_cell]\n            path.append(start)\n            path.reverse()\n            return path\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_cell[0] + dx, current_cell[1] + dy)\n            if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0:\n                tentative_g_score = g_score[current_cell] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current_cell\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n                    \n    return None\ngrid = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nstart = (0, 0)\nend = (2, 3)\npath = a_star(grid, start, end)\nif path:\n    print(f\"Path found: {path}\")\nelse:\n    print(\"No path found.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:55:13.845250"
        },
        "self_built_algorithm_test_function_example": {
            "type": "test",
            "value": "\n# A self-generated algorithm for a simple test case.\n# Discovered concept: A concept for which a working code example was not found online.\ndef add(a, b):\n    return a + b\ndef run_test(func, *args, expected_result):\n    actual_result = func(*args)\n    if actual_result == expected_result:\n        print(f\"Test for {func.__name__} passed! Expected: {expected_result}, Got: {actual_result}\")\n    else:\n        print(f\"Test for {func.__name__} FAILED! Expected: {expected_result}, Got: {actual_result}\")\nrun_test(add, 2, 3, expected_result=5)\nrun_test(add, 1, 1, expected_result=3)\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:59:11.670477"
        },
        "self_built_algorithm_factorial_recursion": {
            "type": "factorial",
            "value": "\n# A self-generated algorithm using recursion.\n# Discovered concept: A function that calls itself to solve smaller versions of the same problem.\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\nnumber = 6\nresult = factorial(number)\nprint(f\"مضروب الرقم {number} هو: {result}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:52:03.102776"
        },
        "self_built_algorithm_git_commit": {
            "type": "git",
            "value": "\n# A self-generated algorithm for version control.\n# Discovered concept: المفهوم: `Software version and release information management.`\ndef git_commit_simulation(message):\n    print(f'\\n>>>>> simulating git commit -m \"{message}\"')\n    print(\"...processing changes...\")\n    print(\"...packaging files...\")\n    print(\"...creating new snapshot...\")\n    print(f\"Commit with message '{message}' successfully created.\")\n    \ngit_commit_simulation(\"first_commit\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:02:23.317792"
        },
        "self_built_algorithm_run_threaded_task": {
            "type": "run",
            "value": "\n# A self-generated algorithm for concurrency.\n# Discovered concept: A concept for which a working code example was not found online.\nimport threading\ndef task(name):\n    print(f\"Task {name} started.\")\n    time.sleep(random.uniform(0.5, 1.5))\n    print(f\"Task {name} finished.\")\nprint(\"Starting concurrent tasks...\")\nt1 = threading.Thread(target=task, args=(\"task1\",))\nt2 = threading.Thread(target=task, args=(\"task2\",))\nt1.start()\nt2.start()\nt1.join()\nt2.join()\nprint(\"All tasks are done.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:00:02.312193"
        },
        "self_built_algorithm_simple_addition_function": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple function.\n# Discovered concept: الكود:\n```py\nimport tensorflow as tf\nimport numpy as np\n\n\ndef create_samples(n_clusters, n_samples_per_cluster, n_features, embiggen_factor, seed):\n    np.random.seed(seed)\n    slices = []\n    centroids = []\n    # 为每个簇创建样本\n    for i in range(n_clusters):\n        samples = tf.random_normal((n_samples_per_cluster, n_features),\n                                   mean=0.0, stddev=5.0, dtype=tf.float32, seed=seed, name=\"cluster_{}\".format(i))\n        current_centroid = (np.random.random((1, n_features)) * embiggen_factor) - (embiggen_factor/2)\n        centroids.append(current_centroid)\n        samples += current_centroid\n        slices.append(samples)\n    # 创建一个大的“样本”数据集\n    samples = tf.concat(slices, 0, name='samples')\n    centroids = tf.concat(centroids, 0, name='centroids')\n    return centroids, samples\n```\nالمفهوم: `A function that generates synthetic data points organized into distinct clusters around randomly determined centers.`\ndef add_two_numbers(a, b):\n    return a + b\nresult = add_two_numbers(4, 10)\nprint(f\"ناتج جمع 4 و 10 هو: {result}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:01:32.629375"
        },
        "self_built_algorithm_define_variable": {
            "type": "define",
            "value": "\n# A self-generated algorithm for defining a variable.\n# Discovered concept: - الكود: `x = 35\n    y = x + 5\n    print(y)`\n- المفهوم: `Direct execution of statements to store and transform data into an observable output.`\nmy_number = 23\nprint(f\"تم إنشاء متغير: {var_name} بقيمة {repr(var_value)}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:57:57.158577"
        },
        "self_built_algorithm_if_statement": {
            "type": "if",
            "value": "\n# A self-generated algorithm for a conditional statement.\n# Discovered concept: - المفهوم: `A library enabling programmatic definition and generation of automation workflows for an external system.`\nmy_number = 7\nif my_number > 50:\n    print(\"الرقم أكبر من 50.\")\nelse:\n    print(\"الرقم ليس أكبر من 50.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:01:57.917918"
        },
        "self_built_algorithm_find_bug": {
            "type": "find",
            "value": "\n# A self-generated algorithm for debugging.\n# Discovered concept: المفهوم: `A boundary error where a string copy operation writes a single null byte beyond the intended buffer end.`\ndef find_bug_simulation(error):\n    print(f'\\n>>>>> simulating debugging for error: \"{error}\"')\n    print(\"...checking syntax...\")\n    print(\"...reviewing logical flow...\")\n    print(f\"Potential fix found for '{error}': Check variable assignments.\")\n    \nfind_bug_simulation(\"syntax_error\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:54:09.640707"
        },
        "self_built_algorithm_create_class_with_inheritance": {
            "type": "create",
            "value": "\n# A self-generated algorithm for class inheritance.\n# Discovered concept: A concept for which a working code example was not found online.\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    def speak(self):\n        raise NotImplementedError(\"Subclass must implement abstract method\")\nclass Dog(Animal):\n    def __init__(self, name):\n        super().__init__(name)\n    def speak(self):\n        return f\"{self.name} makes a sound.\"\nmy_dog = Dog(\"Buddy\")\nprint(f\"The {my_dog.__class__.__name__} says: {my_dog.speak()}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:03:12.260100"
        },
        "self_built_algorithm_linear_search": {
            "type": "linear",
            "value": "\n# A self-generated algorithm for linear search.\n# Discovered concept: - المفهوم: `خوارزميات متنوعة لتحديد موقع عناصر محددة بكفاءة داخل هياكل البيانات.`\ndef linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\ndata = [10, 20, 30, 40, 50]\nitem_to_find = 20\nresult_index = linear_search(data, item_to_find)\nif result_index != -1:\n    print(f\"تم العثور على العنصر {item_to_find} في الفهرس: {result_index}\")\nelse:\n    print(f\"العنصر {item_to_find} غير موجود في القائمة.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:00:54.504693"
        },
        "self_built_algorithm_for_loop_1_to_5": {
            "type": "for",
            "value": "\n# A self-generated algorithm for a loop.\n# Discovered concept: A concept for which a working code example was not found online.\nfor i in range(1, 5 + 1):\n    print(f\"العدد الحالي: {i}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:59:49.409354"
        },
        "self_built_algorithm_graph_mst": {
            "type": "graph",
            "value": "\n# خوارزمية تم توليدها ذاتياً لشجرة الحد الأدنى الامتداد (Minimum Spanning Tree) باستخدام خوارزمية Kruskal.\n# المفهوم المكتشف: An algorithm that finds the minimum spanning tree of a graph by iteratively adding the smallest-weight edges that do not form a cycle, using a Union-Find data structure to detect cycles.\nclass UnionFind:\n    def __init__(self, nodes):\n        self.parent = {node: node for node in nodes}\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_j] = root_i\n            return True\n        return False\ndef kruskal_mst(graph_edges, graph_nodes):\n    result = []\n    i, e = 0, 0\n    graph_edges.sort(key=lambda item: item[2])\n    \n    uf = UnionFind(graph_nodes)\n    while e < len(graph_nodes) - 1:\n        u, v, weight = graph_edges[i]\n        i = i + 1\n        x = uf.find(u)\n        y = uf.find(v)\n        if x != y:\n            e = e + 1\n            result.append((u, v, weight))\n            uf.union(x, y)\n    return result\ngraph_edges = [('A', 'B', 10), ('A', 'C', 6), ('A', 'D', 5), ('B', 'D', 15), ('C', 'D', 4)]\ngraph_nodes = ['A', 'B', 'C', 'D']\nmst_edges = kruskal_mst(graph_edges, graph_nodes)\ntotal_weight = sum(w for u, v, w in mst_edges)\nprint(\"الأضلاع في شجرة الحد الأدنى الامتداد (Kruskal):\")\nfor u, v, w in mst_edges:\n    print(f\" - ({u}, {v}) مع وزن {w}\")\nprint(f\"الوزن الإجمالي لشجرة الحد الأدنى الامتداد: {total_weight}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T09:03:37.756272"
        },
        "self_built_algorithm_create_simple_object": {
            "type": "create",
            "value": "\n# A self-generated algorithm for creating an object from a class.\n# Discovered concept: A concept for which a working code example was not found online.\nclass Car:\n    def __init__(self, color):\n        self.color = color\nmy_car = Car(\"أحمر\")\nprint(f\"تم إنشاء كائن جديد من { my_car.__class__.__name__ } بلون { my_car.color }.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T08:56:17.438647"
        }
    },
    "meta_rules": {
        "general": {
            "type": "general",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "networking": {
            "type": "networking",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "stacks_and_queues": {
            "type": "stacks_and_queues",
            "blueprint": "المفهوم: `A queue that optimizes storage by consolidating consecutive identical elements into item-count pairs.`"
        },
        "polymorphism": {
            "type": "polymorphism",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "dynamic_programming": {
            "type": "dynamic_programming",
            "blueprint": "المفهوم:\n`A practical guide demonstrating essential Python data structures, algorithms, and problem-solving patterns.`"
        },
        "dijkstra_pathfinding": {
            "type": "dijkstra_pathfinding",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "hash_maps": {
            "type": "hash_maps",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "data_types": {
            "type": "data_types",
            "blueprint": "خادم ويب يعالج ويستجيب للأحداث في الوقت الفعلي من خدمة خارجية عبر الـ Webhooks."
        },
        "sorting_algorithm": {
            "type": "sorting_algorithm",
            "blueprint": "المفهوم: `Generating an ordered linear profile from spatially distributed data points.`"
        },
        "a_star_pathfinding": {
            "type": "a_star_pathfinding",
            "blueprint": "المفهوم: `Simulating and controlling a virtual physical environment where objects interact according to defined rules.`"
        },
        "testing": {
            "type": "testing",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "recursion": {
            "type": "recursion",
            "blueprint": "A function that calls itself to solve smaller versions of the same problem."
        },
        "classes": {
            "type": "classes",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "data_structures": {
            "type": "data_structures",
            "blueprint": "- المفهوم: `Assembling and operating a complex system using a high-level library API.`"
        },
        "version_control": {
            "type": "version_control",
            "blueprint": "المفهوم: `Software version and release information management.`"
        },
        "concurrency": {
            "type": "concurrency",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "functions": {
            "type": "functions",
            "blueprint": "الكود:\n```py\nimport tensorflow as tf\nimport numpy as np\n\n\ndef create_samples(n_clusters, n_samples_per_cluster, n_features, embiggen_factor, seed):\n    np.random.seed(seed)\n    slices = []\n    centroids = []\n    # 为每个簇创建样本\n    for i in range(n_clusters):\n        samples = tf.random_normal((n_samples_per_cluster, n_features),\n                                   mean=0.0, stddev=5.0, dtype=tf.float32, seed=seed, name=\"cluster_{}\".format(i))\n        current_centroid = (np.random.random((1, n_features)) * embiggen_factor) - (embiggen_factor/2)\n        centroids.append(current_centroid)\n        samples += current_centroid\n        slices.append(samples)\n    # 创建一个大的“样本”数据集\n    samples = tf.concat(slices, 0, name='samples')\n    centroids = tf.concat(centroids, 0, name='centroids')\n    return centroids, samples\n```\nالمفهوم: `A function that generates synthetic data points organized into distinct clusters around randomly determined centers.`"
        },
        "variables": {
            "type": "variables",
            "blueprint": "- الكود: `x = 35\n    y = x + 5\n    print(y)`\n- المفهوم: `Direct execution of statements to store and transform data into an observable output.`"
        },
        "conditionals": {
            "type": "conditionals",
            "blueprint": "- المفهوم: `A library enabling programmatic definition and generation of automation workflows for an external system.`"
        },
        "debugging": {
            "type": "debugging",
            "blueprint": "المفهوم: `A boundary error where a string copy operation writes a single null byte beyond the intended buffer end.`"
        },
        "inheritance": {
            "type": "inheritance",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "graph_theory": {
            "type": "graph_theory",
            "blueprint": "المفهوم: `Applying a graph algorithm to identify connected components within a network.`"
        },
        "searching_algorithm": {
            "type": "searching_algorithm",
            "blueprint": "- المفهوم: `خوارزميات متنوعة لتحديد موقع عناصر محددة بكفاءة داخل هياكل البيانات.`"
        },
        "loops": {
            "type": "loops",
            "blueprint": "A concept for which a working code example was not found online."
        },
        "kruskal_mst": {
            "type": "kruskal_mst",
            "blueprint": "An algorithm that finds the minimum spanning tree of a graph by iteratively adding the smallest-weight edges that do not form a cycle, using a Union-Find data structure to detect cycles."
        },
        "prim_mst": {
            "type": "prim_mst",
            "blueprint": "An algorithm that finds the minimum spanning tree of a graph by starting from an arbitrary vertex and growing the tree by adding the cheapest edge from the tree to a new vertex, using a min-priority queue to efficiently select the next edge."
        }
    }
}